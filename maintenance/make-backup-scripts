#!/bin/bash

read -d '' USAGE << EOF
Usage: 'make-backup-script'

This script is meant to be invoked from the top of lisc-ttm git tree,
or from the maintenance subdir of same (it will figure out either way).

It prompts you for various pieces of information (the DB read-only
user and password, the backup destination, etc),  then creates
'maintenance/backup-ttm' and 'maintenance/export-backup' from that.

  NOTE: Keep the resultant scripts private, as they will contain a
  password that allows read-only access to all the TTM databases and
  perhaps other sensitive information as well!
EOF

# Set up all the template file and output file paths.
# If we're above the maintenance/ directory, compensate for that.
MAYBE_MAINTENANCE_PREFIX=""
if [ -d maintenance -a -f maintenance/backup-ttm.tmpl ]; then
    MAYBE_MAINTENANCE_PREFIX="maintenance/"
fi
B_TMPL=${MAYBE_MAINTENANCE_PREFIX}backup-ttm.tmpl
B_OUT=${MAYBE_MAINTENANCE_PREFIX}`basename ${B_TMPL} .tmpl`
E_TMPL=${MAYBE_MAINTENANCE_PREFIX}export-backup.tmpl
E_OUT=${MAYBE_MAINTENANCE_PREFIX}`basename ${E_TMPL} .tmpl`
F_TMPL=${MAYBE_MAINTENANCE_PREFIX}fetch-ttm-prod-backup.tmpl
F_OUT=${MAYBE_MAINTENANCE_PREFIX}`basename ${F_TMPL} .tmpl`

# Check that we have everything we need to succeed.
for FNAME in ${B_TMPL} ${E_TMPL} ${F_TMPL}; do
  if [ ! -f ${FNAME} ]; then
    echo "ERROR: could not find '${FNAME}' file."
    exit 1
  fi
done

# Interactively obtain the user-chosen parameters.
read    -p "Top destination directory for backups: " DEST_DIR
read    -p "DB user with read-only access to TTM databases: " DB_USER
read -s -p "Password for DB user: " DB_PASS
read    -p "Directory where exported backups go: " EXPORT_DEST
read -s -p "Encryption key for exported backup: " EXPORT_KEY
read    -p "Base URL for remotely fetching exported backups: " URL
read    -p "Destination directory for exported backup: " REMOTE_DEST_DIR

# We don't expose date format parameterization to the user the way
# we do the others, but they're here in case one wants to tweak them.
# Note that the prefix must be a true prefix of the full format --
# otherwise certain wildcard formulations in the backup script won't
# succeed in cleaning out backups from a fortnight ago.
DATE_YMD_PREFIX="\%Y-\%m-\%d"
DATE_FORMAT="\%Y-\%m-\%d-\%H.\%M.\%S"

# Create the backup script that runs on prod.
cp ${B_TMPL} ${B_OUT}
sed -e "s|__DEST_DIR__|${DEST_DIR}|g" < ${B_OUT} > ${B_OUT}.tmp
mv ${B_OUT}.tmp ${B_OUT}
sed -e "s|__DB_USER__|${DB_USER}|g" < ${B_OUT} > ${B_OUT}.tmp
mv ${B_OUT}.tmp ${B_OUT}
sed -e "s|__DB_PASS__|${DB_PASS}|g" < ${B_OUT} > ${B_OUT}.tmp
mv ${B_OUT}.tmp ${B_OUT}
sed -e "s|__DATE_FORMAT__|${DATE_FORMAT}|g" < ${B_OUT} > ${B_OUT}.tmp
mv ${B_OUT}.tmp ${B_OUT}

# Create the export script that runs on prod.
cp ${E_TMPL} ${E_OUT}
sed -e "s|__EXPORT_DEST__|${EXPORT_DEST}|g" < ${E_OUT} > ${E_OUT}.tmp
mv ${E_OUT}.tmp ${E_OUT}
sed -e "s|__EXPORT_KEY__|${EXPORT_KEY}|g" < ${E_OUT} > ${E_OUT}.tmp
mv ${E_OUT}.tmp ${E_OUT}
sed -e "s|__DATE_YMD_PREFIX__|${DATE_YMD_PREFIX}|g" < ${E_OUT} > ${E_OUT}.tmp
mv ${E_OUT}.tmp ${E_OUT}

# Create the remote-backup fetch script that runs somewhere off site.
cp ${F_TMPL} ${F_OUT}
sed -e "s|__URL__|${URL}|g" < ${F_OUT} > ${F_OUT}.tmp
mv ${F_OUT}.tmp ${F_OUT}
sed -e "s|__DEST_DIR__|${REMOTE_DEST_DIR}|g" < ${F_OUT} > ${F_OUT}.tmp
mv ${F_OUT}.tmp ${F_OUT}
sed -e "s|__DATE_YMD_PREFIX__|${DATE_YMD_PREFIX}|g" < ${F_OUT} > ${F_OUT}.tmp
mv ${F_OUT}.tmp ${F_OUT}

# Make sure the outputs are all executable.
chmod a+x ${B_OUT}
chmod a+x ${E_OUT}
chmod a+x ${F_OUT}

echo ""
echo "Backup scripts created:"
echo ""
echo "  ${B_OUT}"
echo "  ${E_OUT}"
echo "  ${F_OUT}"
echo ""
